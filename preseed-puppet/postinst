#!/bin/sh

set -e

# You can obtain a host's host keys with ssh-keyscan(1).
PUPPET_MASTER=puppetmaster.horde.net
PUPPET_MASTER_HOST_KEYS='
	# puppetmaster.horde.net SSH-2.0-OpenSSH_5.5p1 Debian-6+squeeze2
	puppetmaster.horde.net ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEApvK1UoJ3C3hxFmxTuP/HycQeeKmRROAqET9LbiMmXYvj4EpvaSCZl3aMJPEADCGzxz8nRVYhmoEIwFeJY2a1UMxC7Tao4Z962SjPGnOpfgK4Ef3iRDRlognOGVo1x6ILx705e+nwtDpWGedJA1y2CSYEWcPw915q15lx8w/LYn1TEeYYFo8K/mlU9R++d+MKsSpZCAi2B5YJ01jc7VXD2YGC5dPeBkVWghiVBcQw1JzezY6xscyQsbi15AoUwA9HHnFqiTSIQuaN48idwhygAOTr4/ECOt4YGW8/ArrFU+qvlUURTauVPSEVuplhdsFuIDnxv6N/Y1IYKrRHUOLiRQ==
'


. /lib/chroot-setup.sh
. /usr/share/debconf/confmodule
PROGNAME=$(basename "$0")

CHROOT_PATH=/target
CHROOT="chroot $CHROOT_PATH"
HOSTNAME=$($CHROOT hostname -f)

# It's easier to not worry about whether the Puppet bootstrap code is only
# using utilities present in busybox, so give it transparent access to
# binaries in the installed system.
#
# It would have been nice to simply chroot the rest of this into
# $CHROOT_PATH, but http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=439763
# makes Debconf interaction broken, so we need to stay out of the chroot to
# use Debconf and have the scripts chroot the parts that are necessary.
arch=$(uname -m)
export LD_LIBRARY_PATH=/lib:/usr/lib:/lib/$arch-linux-gnu:/usr/lib/$arch-linux-gnu:/target/lib:/target/usr/lib:/target/lib/$arch-linux-gnu:/target/usr/lib/$arch-linux-gnu
export PATH="$PATH:/target/bin:/target/usr/bin:/target/sbin:/target/usr/sbin"

# Set up the chroot (in particular, mount the various pseudofilesystems),
# because expect(1) needs ptys to spawn external commands.
chroot_setup

# chroot_setup unset a bunch of {DEBCONF,DEBIAN}_* environment vars.
# Make sure we can still talk to the Debconf frontend. This is basically
# forklifted from d-i's in-target(8).
DEBCONF_READFD=0
export DEBCONF_READFD
DEBCONF_WRITEFD=3
export DEBCONF_WRITEFD
DEBIAN_FRONTEND=passthrough
export DEBIAN_FRONTEND

trap chroot_cleanup EXIT

tmpfile=$(mktemp -t "$PROGNAME.XXXXXXXXXX")
cat >"$tmpfile" <<-EOF
	Template: di-postinst/setup_cert_username
	Type: string
	Description: $PUPPET_MASTER Username:
	 Your $PUPPET_MASTER account will be used to set up the
	 Puppet client certificate for this host.

	Template: di-postinst/setup_cert_password
	Type: password
	Description: $PUPPET_MASTER Password:
	 Your $PUPPET_MASTER account will be used to set up the
	 Puppet client certificate for this host.

	Template: di-postinst/cert_generation_failed
	Type: text
	Description: Certificate generation failed
	 Puppet was unable to generate a client certificate
	 for this host. Examine the puppet-agent installer
	 syslogs for more details.
	 .
	 This host's configuration will not be applied by
	 Puppet until its client certificate is generated
	 and signed manually.

	Template: di-postinst/cert_already_exists
	Type: boolean
	Default: true
	Description: Purge existing client certificate on $PUPPET_MASTER?
	 The client certificate for this host already
	 exists on $PUPPET_MASTER. Usually, this indicates
	 you're reinstalling a host whose name was previously
	 registered.
	 .
	 If you're sure no other host with this hostname
	 is currently running Puppet, you can purge the
	 existing client certificate from $PUPPET_MASTER.
	 A new certificate will be generated for this host.
	 .
	 Otherwise, Puppet won't apply this host's
	 configuration. You will need to resolve the
	 situation manually.

	Template: di-postinst/cert_fingerprint_mismatch
	Type: text
	Description: Client certificate fingerprint mismatch
	 The fingerprint of this host's client certificate
	 does not match the fingerprint generated by
	 $PUPPET_MASTER. This may indicate a security
	 breach, or that a different machine with this same
	 hostname was registered with Puppet in the past.
	 .
	 This machine's configuration will not be applied
	 by Puppet until its client certificate is
	 configured and signed manually.

	Template: di-postinst/cert_signing_retry
	Type: boolean
	Default: true
	Description: Try to sign client certificate again?
	 There was a problem signing this host's client
	 certificate on $PUPPET_MASTER. Examine the
	 puppet-agent installer syslogs for more details.
	 .
	 Often, this indicates that you just mistyped the
	 credentials for your $PUPPET_MASTER account.

	Template: di-postinst/cert_signing_failed
	Type: text
	Description: Failed to sign client certificate
	 There was a problem signing this host's client
	 certificate on $PUPPET_MASTER. Examine the
	 puppet-agent installer syslogs for more details.
	 .
	 This host's configuration will not be applied
	 by Puppet until its client certificate is
	 configured and signed manually.

	Template: di-postinst/initial_run_title
	Type: text
	Description: Applying configuration with Puppet

	Template: di-postinst/initial_run_info
	Type: text
	Description: \${LINE}

	Template: di-postinst/initial_run_failed
	Type: text
	Description: Failed to apply Puppet configuration
	 Puppet failed when applying this machine's configuration.
	 .
	 Examine the installer syslogs for more details.
EOF
db_x_loadtemplatefile "$tmpfile" di-postinst
rm -f "$tmpfile"

sanitize_command()
{
	# Escape expect(1) metacharacters, so commands passed to
	# sanitize_command() can be written just as they would be at
	# a command prompt.
	echo $* | sed -e 's/\([][{}$;\\"]\)/\\\1/g'
}

ssh_command()
{
	# dash(1) doesn't support assignment in the local statement.
	local hostname
	hostname=$(sanitize_command "$1")
	shift

	local username
	username=$(sanitize_command "$1")
	shift

	local password
	password=$(sanitize_command "$1")
	shift

	local command
	command=$(sanitize_command "$@")

	hostkeys_file=$($CHROOT mktemp -t "$PROGNAME.XXXXXXXXXX")
	echo "$PUPPET_MASTER_HOST_KEYS" >"$CHROOT_PATH$hostkeys_file"

	# expect(1) can't find its TCL libraries (init.tcl et al)
	# unless it's chrooted, even when I set TCLLIBPATH.
	$CHROOT expect <<-EOF_EXPECT
		set timeout 60
		log_user 1
		spawn ssh -to NumberOfPasswordPrompts=1 \
			-o GlobalKnownHostsFile=$hostkeys_file \
			$username@$hostname $command
		expect {
			-re "(\[Pp\]assword:|\\\\\[sudo\\\\\] password for $username:)" {
				send "$password\r"
				exp_continue
			} -ex "Are you sure you want to continue connecting (yes/no)?" {
				send "no\r"
				exit 1
			} -ex "Host key verification failed." {
				send_error "Host key verification failed - $username@$hostname.\n"
				exit 1
			} -ex "Permission denied" {
				send_error "Possible Invalid Password - $username@$hostname.\n"
				exit 1
			} -ex "Name or service not known" {
				send_error "Possible Invalid Hostname - $hostname.\n"
				exit 1
			} -ex "No route to host" {
				send_error "No route to host - $hostname.\n"
				exit 1
			} eof {
				# FIXME: it'd be nice if we could get the exit status of
				# the command we executed.
				exit 0
			} timeout {
				close -i \$spawn_id
				wait -i \$spawn_id
				send_error "timeout: \$timeout seconds - $hostname.\n";
				exit 1
			}
		}
EOF_EXPECT
}

sign_cert()
{
	set -e

	local username password
	local remote_fprint status local_fprint

	while [ -z "$username" ]; do
		db_get di-postinst/setup_cert_username
		username=$RET
		if [ -z "$username" ]; then
			db_fset di-postinst/setup_cert_username seen false
			db_input critical di-postinst/setup_cert_username || true
			db_go || true
		fi
	done
	db_set di-postinst/setup_cert_username ''

	while [ -z "$password" ]; do
		db_get di-postinst/setup_cert_password
		password=$RET
		if [ -z "$password" ]; then
			db_fset di-postinst/setup_cert_password seen false
			db_input critical di-postinst/setup_cert_password || true
			db_go || true
		fi
	done
	db_set di-postinst/setup_cert_password ''

	if [ ! -e "$CHROOT_PATH/var/lib/puppet/ssl/certificate_requests/$HOSTNAME.pem" ]; then
		remote_fprint=$(ssh_command "$PUPPET_MASTER" "$username" "$password" \
			sudo puppet cert -l --digest SHA256 "$HOSTNAME"
		)
		case $remote_fprint in
		*'Could not find a certificate'*)
			# As expected, so fall through.
			;;
		*)
			db_fset di-postinst/cert_already_exists seen false
			db_input critical di-postinst/cert_already_exists || true
			db_go || true

			db_get di-postinst/cert_already_exists
			if [ "$RET" = false ]; then
				exit 0
			fi

			ssh_command "$PUPPET_MASTER" "$username" "$password" \
				sudo puppet cert -c "$HOSTNAME"
			;;
		esac
	fi

	# Puppet won't resubmit certificate requests on failure, such as a
	# refused connection when attempting to contact the Puppet master.
	# We might be retrying, so make sure there's no existing request.
	# http://projects.puppetlabs.com/issues/4680
	rm -f "$CHROOT_PATH/var/lib/puppet/ssl/certificate_requests/$HOSTNAME.pem"

	# Generate the client certificate. Without --waitforcert, generates
	# the client certificate, sees that the remote server hasn't signed it,
	# and exits.
	set +e
	output=$($CHROOT puppet agent --no-daemonize -v \
		--onetime --noop --no-splay --detailed-exitcodes 2>&1)
	status=$?
	set -e

	case $status in
	0)
		# The client cert is already in order; there's nothing
		# more for us to do.
		echo "$output" | logger -t di-postinst
		logger -t di-postinst "Certificate generation exited with status $status (cert already exists)"
		exit 0
		;;
	1)
		# Fall through; we know the agent won't be able to fetch
		# a signed cert from the Puppet master at this point.
		;;
	*)
		echo "$output" | logger -t di-postinst
		logger -t di-postinst "Certificate generation exited with status $status"

		db_fset di-postinst/cert_generation_failed seen false
		db_input critical di-postinst/cert_generation_failed || true
		exit $status
		;;
	esac

	remote_fprint=$(ssh_command "$PUPPET_MASTER" "$username" "$password" \
		sudo puppet cert -l --digest SHA256 "$HOSTNAME"
	)
	echo "Remote fingerprint output for $HOSTNAME:" | logger -t di-postinst
	echo "$remote_fprint" | logger -t di-postinst
	# 'puppet cert' output contains a leading '+ ' if the cert has
	# already been signed. Ignore that and sign the cert anyway,
	# since signing is idempotent.
	remote_fprint=$(echo "$remote_fprint" | \
		sed -rn '/^\+?[[:space:]]*"?'"$HOSTNAME"'"?[[:space:]]*\(.*\)[[:space:]]*(.*)[[:space:]]+$/s//\1/p')
	echo "Parsed remote fingerprint for $HOSTNAME: $remote_fprint" | logger -t di-postinst

	local_fprint=$(
		$CHROOT puppet agent --no-daemonize -v --noop --no-splay \
		--fingerprint --digest SHA256)
	local_fprint=$(echo "$local_fprint" | sed 's/^notice:[[:space:]]*//')
	echo "Local fingerprint: $local_fprint" | logger -t di-postinst

	if [ "$remote_fprint" != "$local_fprint" ]; then
		db_fset di-postinst/cert_fingerprint_mismatch seen false
		db_input critical di-postinst/cert_fingerprint_mismatch || true
		db_go || true

		exit 0
	fi

	ssh_command "$PUPPET_MASTER" "$username" "$password" \
		sudo puppet cert -s "$HOSTNAME"
}

echo "set /files/etc/puppet/puppet.conf/agent/report true
	set /files/etc/puppet/puppet.conf/main/color false
	set /files/etc/puppet/puppet.conf/main/pluginsync true
	set /files/etc/puppet/puppet.conf/main/runinterval 3600
	set /files/etc/puppet/puppet.conf/main/server $PUPPET_MASTER
	set /files/etc/puppet/puppet.conf/main/splay true
	set /files/etc/default/puppet/START yes
	save" | $CHROOT augtool >/dev/null

while true; do
	# errexit doesn't apply to functions when the function is called in
	# a conditional, e.g. where foo is a function:
	#
	#   if ! foo; then
	#       # handle it
	#   fi
	#
	# The function simply plows on in the face of failure. We can't even:
	#
	#   ! foo || break
	#
	# since this behaves somewhat as we would expect (the 'break' is
	# executed when foo has an unsuccessful return status), but 'set -e'
	# *still* doesn't apply in the function foo.
	#
	# The best way I've found out of this is to explicitly:
	# - disable errexit here
	# - enable errexit in the called function
	# - gather $?
	# - check $?
	set +e
	output=$(sign_cert 2>&1)
	status=$?
	set -e

	if [ "$status" -eq 0 ]; then
		break
	fi

	echo "$output" | logger -t di-postinst

	db_fset di-postinst/cert_signing_retry seen false
	db_input critical di-postinst/cert_signing_retry || true
	db_go || true

	db_get di-postinst/cert_signing_retry
	if [ "$RET" = false ]; then
		db_fset di-postinst/cert_signing_failed seen false
		db_input critical di-postinst/cert_signing_failed || true
		db_go || true

		exit 0
	fi
done

# 600 is an arbitrary maximum number of lines we should expect from
# an initial Puppet run. YMMV.
db_progress START 0 600 di-postinst/initial_run_title

fifo_name=$(TMPDIR=/target/tmp mktemp -t "$PROGNAME.XXXXXXXXXX")
rm -f "$fifo_name"
mkfifo "$fifo_name"

chroot /target puppet agent --no-daemonize --waitforcert 3 \
	-v --onetime --no-splay --detailed-exitcodes >"$fifo_name" 2>&1 &
agent_pid=$!

# 'read -u' isn't a POSIX feature and therefore isn't implemented by dash(1),
# but busybox implements it, so that's good enough to use with d-i.
# It would be nice to use $DEBCONF_OLD_FD_BASE instead of hardcoding 4,
# but input redirection only allows a numeric FD, not an expanded word.
#
# We can't easily juggle file descriptors around to avoid 'read -u' since
# the body of the loop needs to interact with the Debconf frontend and we'd
# have to swap them every time through the loop.
while read -u 4 line; do
	# Puppet only syslogs the first line of failed execs, and it's
	# nice to have its full output in the event of problems.
	logger -t "$PROGNAME" -- "$line"

	db_progress STEP 1
	db_subst di-postinst/initial_run_info LINE "$line"
	db_progress INFO di-postinst/initial_run_info
done 4<"$fifo_name"

set +e
wait $agent_pid
status=$?
set -e

if [ $(($status & 4)) -eq 4 ] || [ $(($status & 1)) -eq 1 ]; then
	db_progress STOP

	# There were failures during the run.
	db_input critical di-postinst/initial_run_failed || true
	db_go || true
else
	db_progress SET 600
	sleep 1
	db_progress STOP
fi

# We don't bother removing the Debconf templates we registered, since we
# registered them with the installer's instance of Debconf, not the instance
# in the finished system. This is a little sloppy, but it's not a big deal.

exit 0
